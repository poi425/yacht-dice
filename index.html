<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Yacht Dice Online</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Noto Sans KR -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap"
    rel="stylesheet"
  />

  <style>
    :root {
      --bg: #16171b;
      --bg-elevated: #1f2026;
      --bg-soft: #252730;
      --border-subtle: #2f3138;
      --border-strong: #3f3f46;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --accent: #4b8af1;
      --accent-soft: #1e293b;
      --danger: #f97373;
      --dice-size: 56px;
      --radius-lg: 14px;
      --radius-md: 10px;
      --radius-pill: 999px;
    }

    * { box-sizing: border-box; }

    html { font-size: 14px; }

    body {
      margin: 0;
      min-height: 100vh;
      background-color: var(--bg);
      color: var(--text-main);
      font-family: 'Noto Sans KR', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ìƒë‹¨ ë°” */
    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--border-subtle);
      background: #0b0b0d;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .logo {
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-main);
    }

    .room-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .room-id {
      padding: 3px 8px;
      border-radius: var(--radius-pill);
      border: 1px solid var(--border-subtle);
      background: #121217;
      max-width: 130px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btn {
      border: none;
      border-radius: var(--radius-pill);
      padding: 6px 10px;
      font-size: 0.78rem;
      font-weight: 500;
      background: var(--bg-elevated);
      color: var(--text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      outline: none;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.08s ease;
    }

    .btn:hover { background: #22222a; }
    .btn:active { transform: translateY(1px); box-shadow: none; }

    .btn-primary {
      background: var(--accent);
      color: white;
    }
    .btn-primary:hover { background: #3b7ae0; }

    .btn:disabled,
    .btn-primary:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    main.layout {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px 10px 16px;
      max-width: 960px;
      width: 100%;
      margin: 0 auto;
    }

    .panel {
      background: var(--bg-elevated);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 12px 12px 10px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 8px;
    }

    .section-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .section-sub {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .pill {
      border-radius: var(--radius-pill);
      border: 1px solid var(--border-subtle);
      padding: 4px 8px;
      font-size: 0.74rem;
      color: var(--text-muted);
      background: #121217;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #22c55e;
    }

    .pill-dot.me { background: var(--accent); }

    /* ì£¼ì‚¬ìœ„ ì˜ì—­ */
    .dice-area { display: flex; flex-direction: column; gap: 10px; }

    .dice-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .die {
      flex: 0 0 auto;
      width: var(--dice-size);
      height: var(--dice-size);
      border-radius: var(--radius-md);
      background: #151518;
      border: 1px solid var(--border-strong);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: 500;
      cursor: pointer;
      position: relative;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: background 0.1s ease, border-color 0.1s ease, transform 0.08s ease, box-shadow 0.08s ease;
    }

    .die-label {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 0.65rem;
      color: var(--text-muted);
      opacity: 0.9;
    }

    .die:hover { background: #1b1b20; }
    .die:active { transform: translateY(1px); box-shadow: none; }

    .die-held {
      background: #1e1e23;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(75, 138, 241, 0.6);
    }
    .die-held .die-label { color: var(--accent); }

    .dice-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .info-pill {
      border-radius: var(--radius-pill);
      border: 1px solid var(--border-subtle);
      padding: 4px 9px;
      font-size: 0.78rem;
      color: var(--text-muted);
      background: #121217;
    }

    .warn { color: var(--danger); }

    /* ì ìˆ˜í‘œ (ë¼ì´íŠ¸í†¤) */
    .score-wrapper { overflow-x: auto; }

    .score-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      min-width: 360px;
      background: #e5e7eb;
      color: #111827;
    }

    .score-table th,
    .score-table td {
      border: 1px solid #cbd5e1;
      padding: 4px 6px;
      text-align: right;
      white-space: nowrap;
    }

    .score-table th {
      background: #e2e8f0;
      font-weight: 500;
      color: #111827;
    }

    .score-table th.category-header {
      text-align: left;
      width: 120px;
    }

    .score-category {
      text-align: left;
      background: #d4d4d8;
      color: #111827;
      position: relative;
      cursor: help;
    }

    .score-cell {
      background: #f9fafb;
      color: #111827;
      min-width: 60px;
    }

    .score-cell.locked {
      background: #e5e7eb;
      color: #111827;
      font-weight: 600;
    }

    .score-cell.candidate {
      background: #eef2ff;
      color: #1d4ed8;
      cursor: pointer;
    }
    .score-cell.candidate:hover { background: #e0e7ff; }

    .score-cell.disabled { color: #9ca3af; }

    .score-total-row th,
    .score-total-row td {
      background: #e5e7eb;
      font-weight: 700;
      border-top: 1px solid #94a3b8;
    }

    .score-status {
      font-size: 0.76rem;
      color: #9ca3af;
      margin-top: 6px;
    }
    .score-status.finished { color: #4b8af1; }

    .tooltip { position: relative; }
    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 0;
      bottom: 100%;
      transform: translateY(-4px);
      max-width: 220px;
      padding: 6px 8px;
      border-radius: 6px;
      background: #111827;
      color: #e5e7eb;
      font-size: 0.7rem;
      line-height: 1.3;
      white-space: normal;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.6);
      z-index: 5;
    }
    .tooltip:hover::after { opacity: 1; }

    /* ì˜¤ë²„ë ˆì´ (ë‹‰ë„¤ì„) */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 5, 7, 0.86);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 20;
    }

    .dialog {
      width: 100%;
      max-width: 360px;
      border-radius: 16px;
      background: #15151b;
      border: 1px solid var(--border-strong);
      padding: 16px 16px 14px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
    }

    .dialog-title {
      margin: 0 0 8px;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .dialog-text {
      margin: 0 0 12px;
      font-size: 0.82rem;
      color: var(--text-muted);
    }

    .dialog-subtext {
      margin: 8px 0 0;
      font-size: 0.72rem;
      color: var(--text-muted);
    }

    .text-input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border-strong);
      background: #101014;
      padding: 7px 9px;
      font-size: 0.86rem;
      color: var(--text-main);
      outline: none;
      margin-bottom: 10px;
    }

    .text-input::placeholder { color: #6b7280; }
    .text-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(75, 138, 241, 0.5);
    }

    .btn-block {
      width: 100%;
      justify-content: center;
      padding-top: 7px;
      padding-bottom: 7px;
      font-size: 0.9rem;
    }

    .btn-secondary {
      background: #27272f;
      color: #e5e7eb;
    }
    .btn-secondary:hover { background: #32323a; }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: #18181b;
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 0.78rem;
      color: var(--text-main);
      border: 1px solid var(--border-strong);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 30;
    }
    .toast.show { opacity: 1; }

    @media (min-width: 720px) {
      main.layout {
        flex-direction: row;
        align-items: flex-start;
      }
      .panel-main { flex: 1.3; }
      .panel-side { flex: 1.7; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="top-bar">
      <div class="logo">YACHT</div>
      <div class="room-info">
        <span class="room-id" id="roomIdText">ë°© ì¤€ë¹„ ì¤‘â€¦</span>
        <button class="btn" id="copyLinkBtn" type="button">ë§í¬ ë³µì‚¬</button>
      </div>
    </header>

    <main class="layout" id="game-screen">
      <!-- ì£¼ì‚¬ìœ„ / í„´ -->
      <section class="panel panel-main">
        <div class="section-header">
          <div>
            <div class="section-title">ìš”íŠ¸ ë‹¤ì´ìŠ¤</div>
            <div class="section-sub">
              ì£¼ì‚¬ìœ„ë¥¼ ì„ íƒí•´ì„œ ê³ ì •í•˜ê³ , í•œ í„´ì— ìµœëŒ€ 3ë²ˆê¹Œì§€ êµ´ë¦° ë’¤<br />
              ì ìˆ˜í‘œì—ì„œ ì›í•˜ëŠ” ì¹¸ì„ ëˆŒëŸ¬ ì ìˆ˜ë¥¼ í™•ì •í•©ë‹ˆë‹¤.
            </div>
          </div>
          <div class="pill">
            <span class="pill-dot me"></span>
            <span id="myNameBadge">ë‚˜</span>
          </div>
        </div>

        <div class="dice-area">
          <div class="section-header" style="margin-bottom: 6px;">
            <div class="section-sub">
              í˜„ì¬ í„´:
              <strong id="currentTurnName">-</strong>
            </div>
            <div class="section-sub" id="turnHint">ë‹‰ë„¤ì„ ì…ë ¥ í›„ ì‹œì‘ë©ë‹ˆë‹¤.</div>
          </div>

          <div class="dice-row" id="diceContainer"></div>

          <div class="dice-controls">
            <button class="btn btn-primary" id="rollButton" type="button" disabled>ğŸ² êµ´ë¦¬ê¸°</button>
            <span class="info-pill" id="rollInfo">ì—°ê²° ì¤‘â€¦</span>
            <span class="info-pill" id="turnTimer">ë‚¨ì€ ì‹œê°„: -</span>
            <button class="btn" id="forceSkipButton" type="button" disabled>â± ê°•ì œ í„´ ë„˜ê¸°ê¸°</button>
          </div>
        </div>
      </section>

      <!-- ì ìˆ˜í‘œ -->
      <section class="panel panel-side">
        <div class="section-header">
          <div class="section-title">ì ìˆ˜í‘œ</div>
          <div class="section-sub" id="playerCountText">0ëª…</div>
        </div>
        <div class="score-wrapper">
          <table class="score-table" id="scoreTable"></table>
        </div>
        <div class="score-status" id="scoreStatus"></div>
      </section>
    </main>

    <!-- ë‹‰ë„¤ì„ ì˜¤ë²„ë ˆì´ -->
    <div class="overlay" id="nameOverlay">
      <div class="dialog">
        <h1 class="dialog-title">ë‹‰ë„¤ì„ ì„¤ì •</h1>
        <p class="dialog-text">
          í•¨ê»˜ í”Œë ˆì´í•  ë•Œ ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ ë³´ì¼ ì´ë¦„ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”.
        </p>
        <input
          id="nameInput"
          class="text-input"
          type="text"
          maxlength="16"
          autocomplete="off"
          placeholder="ì˜ˆ: P í•´ë¦¬ í¬í„°, D í†° ë¦¬ë“¤"
        />
        <button class="btn btn-primary btn-block" id="enterButton" type="button" disabled>
          ì…ì¥í•˜ê¸°
        </button>
        <button class="btn btn-secondary btn-block" id="spectateButton" type="button" disabled>
          ê´€ì „í•˜ê¸°
        </button>
        <p class="dialog-subtext">
          ê°™ì€ ë§í¬ë¡œ ì ‘ì†í•œ ì‚¬ëŒë“¤ê³¼ ê°™ì€ ë°©ì—ì„œ ì£¼ì‚¬ìœ„ë¥¼ ê³µìœ í•©ë‹ˆë‹¤.
        </p>
      </div>
    </div>

    <div class="toast" id="toast">ë§í¬ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.</div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      onSnapshot,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    // ==== Firebase ì„¤ì • (ì—¬ê¸°ë§Œ ë„¤ ê°’ìœ¼ë¡œ êµì²´) ====
    const firebaseConfig = {
      apiKey: "AIzaSyAAelAGDvaal7dOSuZQct0p2qqCByGk__E",
      authDomain: "yacht-f5a71.firebaseapp.com",
      projectId: "yacht-f5a71",
      storageBucket: "yacht-f5a71.firebasestorage.app",
      messagingSenderId: "465967593594",
      appId: "1:465967593594:web:ab5ea29bed6bcf934fe3c3",
      measurementId: "G-88JD78PP2W"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ==== DOM ====
    const diceContainer = document.getElementById("diceContainer");
    const rollButton = document.getElementById("rollButton");
    const rollInfo = document.getElementById("rollInfo");
    const currentTurnNameEl = document.getElementById("currentTurnName");
    const turnHintEl = document.getElementById("turnHint");
    const playerCountText = document.getElementById("playerCountText");
    const myNameBadge = document.getElementById("myNameBadge");
    const roomIdText = document.getElementById("roomIdText");
    const copyLinkBtn = document.getElementById("copyLinkBtn");

    const scoreTableEl = document.getElementById("scoreTable");
    const scoreStatusEl = document.getElementById("scoreStatus");

    const nameOverlay = document.getElementById("nameOverlay");
    const nameInput = document.getElementById("nameInput");
    const enterButton = document.getElementById("enterButton");
    const spectateButton = document.getElementById("spectateButton");
    const toastEl = document.getElementById("toast");

    const turnTimerEl = document.getElementById("turnTimer");
    const forceSkipButton = document.getElementById("forceSkipButton");

    // ==== ìƒìˆ˜ & ìƒíƒœ ====
    const NUM_DICE = 5;
    const MAX_ROLLS_PER_TURN = 3;
    const TURN_LIMIT_SECONDS = 180;
    const MAX_TURNS_PER_PLAYER = 13;

    let roomId = null;
    let roomRef = null;
    let currentUser = null;
    let isRoomReady = false;
    let latestRoomData = null;
    let playerOrder = [];
    let isSpectator = false;
    let turnTimerInterval = null;

    // ì¹´í…Œê³ ë¦¬ ìˆœì„œ: ìƒë‹¨(1~6) â†’ 3K,4K,í’€,ìŠ¤ëª°,ë¼ì§€, ì°¬ìŠ¤, ìš”íŠ¸
    const CATEGORIES = [
      { key: "ones",   label: "1",   desc: "1ì˜ í•©" },
      { key: "twos",   label: "2",   desc: "2ì˜ í•©" },
      { key: "threes", label: "3",   desc: "3ì˜ í•©" },
      { key: "fours",  label: "4",   desc: "4ì˜ í•©" },
      { key: "fives",  label: "5",   desc: "5ì˜ í•©" },
      { key: "sixes",  label: "6",   desc: "6ì˜ í•©" },

      { key: "threeKind", label: "3-kind", desc: "ì¡°ê±´ ì¶©ì¡± ì‹œ 23ì " },
      { key: "fourKind",  label: "4-kind", desc: "ì¡°ê±´ ì¶©ì¡± ì‹œ 17ì " },
      { key: "fullHouse", label: "í’€í•˜ìš°ìŠ¤", desc: "25ì  (3+2)" },
      { key: "smallStraight", label: "ìŠ¤ëª°", desc: "30ì  (ì—°ì† 4ê°œ)" },
      { key: "largeStraight", label: "ë¼ì§€", desc: "40ì  (ì—°ì† 5ê°œ)" },
      { key: "chance", label: "ì°¬ìŠ¤", desc: "ì£¼ì‚¬ìœ„ ëˆˆì˜ í•©" },
      { key: "yacht", label: "ìš”íŠ¸", desc: "50ì  (ê°™ì€ ëˆˆ 5ê°œ) Â· ì¶”ê°€ ìš”íŠ¸ë§ˆë‹¤ ë³´ë„ˆìŠ¤" }
    ];

    // ==== ìœ í‹¸ ====
    function showToast(msg, ms = 1800) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), ms);
    }

    function getRoomIdFromUrlOrCreate() {
      const url = new URL(window.location.href);
      const params = url.searchParams;
      let id = params.get("room");
      if (!id) {
        id = crypto.randomUUID();
        params.set("room", id);
        const newUrl = `${url.pathname}?${params.toString()}`;
        window.history.replaceState({}, "", newUrl);
      }
      return id;
    }

    function shortenId(id) {
      if (!id) return "";
      return id.slice(0, 6);
    }

    function computeCounts(dice) {
      const counts = [0, 0, 0, 0, 0, 0, 0];
      dice.forEach((v) => {
        if (v >= 1 && v <= 6) counts[v]++;
      });
      return counts;
    }

    function uniqueSorted(dice) {
      const set = new Set(dice.filter((v) => v > 0));
      return Array.from(set).sort((a, b) => a - b);
    }

    function computeScore(categoryKey, dice) {
      const d = dice.filter((v) => v > 0);
      if (d.length === 0) return 0;
      const counts = computeCounts(d);
      const sum = d.reduce((a, b) => a + b, 0);
      const uniq = uniqueSorted(d);

      switch (categoryKey) {
        case "ones":
        case "twos":
        case "threes":
        case "fours":
        case "fives":
        case "sixes": {
          const n = { ones: 1, twos: 2, threes: 3, fours: 4, fives: 5, sixes: 6 }[categoryKey];
          return counts[n] * n;
        }
        case "chance":
        case "choice": // êµ¬ë²„ì „ í˜¸í™˜
          return sum;
        case "threeKind":
          return counts.some((c) => c >= 3) ? 23 : 0;
        case "fourKind":
          return counts.some((c) => c >= 4) ? 17 : 0;
        case "fullHouse": {
          const has3 = counts.some((c) => c === 3);
          const has2 = counts.some((c) => c === 2);
          return has3 && has2 ? 25 : 0;
        }
        case "smallStraight": {
          const s = new Set(uniq);
          const patterns = [
            [1, 2, 3, 4],
            [2, 3, 4, 5],
            [3, 4, 5, 6]
          ];
          const ok = patterns.some((p) => p.every((v) => s.has(v)));
          return ok ? 30 : 0;
        }
        case "largeStraight": {
          const s = new Set(uniq);
          const p1 = [1, 2, 3, 4, 5];
          const p2 = [2, 3, 4, 5, 6];
          const ok = p1.every((v) => s.has(v)) || p2.every((v) => s.has(v));
          return ok ? 40 : 0;
        }
        case "yacht":
          return counts.some((c) => c === 5) ? 50 : 0;
        default:
          return 0;
      }
    }

    // ìƒë‹¨(1~6)ì˜ í•©ì´ 63 ì´ìƒì´ë©´ 35ì , ì•„ë‹ˆë©´ 0ì 
    function computeUpperBonus(playerScores) {
      if (!playerScores) return 0;
      const keys = ["ones", "twos", "threes", "fours", "fives", "sixes"];
      let total = 0;
      for (const k of keys) {
        const v = playerScores[k];
        if (typeof v === "number") total += v;
      }
      return total >= 63 ? 35 : 0;
    }

    // ìš”íŠ¸ ë³´ë„ˆìŠ¤: ì²« ìš”íŠ¸ëŠ” x1, ì¶”ê°€ ìš”íŠ¸ë§ˆë‹¤ +100ì 
    function computeYachtBonus(playerScores) {
      if (!playerScores) return 0;
      const count = playerScores.yachtCount ?? 0;
      if (count <= 1) return 0;
      return (count - 1) * 100;
    }

    function computePlayerTotal(playerScores) {
      if (!playerScores) return 0;
      let total = 0;
      for (const cat of CATEGORIES) {
        const v = playerScores[cat.key];
        if (typeof v === "number") total += v;
      }
      total += computeUpperBonus(playerScores);
      total += computeYachtBonus(playerScores);
      return total;
    }

    function allTurnsFinished(turnCounts, playerIds) {
      const tc = turnCounts || {};
      return playerIds.every((uid) => {
        const n = tc[uid] ?? 0;
        return n >= MAX_TURNS_PER_PLAYER;
      });
    }

    // ==== UI: ì£¼ì‚¬ìœ„ ====
    function createDiceUI() {
      diceContainer.innerHTML = "";
      for (let i = 0; i < NUM_DICE; i++) {
        const die = document.createElement("div");
        die.className = "die";
        die.dataset.index = String(i);

        const label = document.createElement("div");
        label.className = "die-label";
        label.textContent = `D${i + 1}`;
        die.appendChild(label);

        die.addEventListener("click", () => onDieClick(i));
        diceContainer.appendChild(die);
      }
    }

    function renderDice(diceValues = [], held = []) {
      const dieEls = diceContainer.getElementsByClassName("die");
      for (let i = 0; i < dieEls.length; i++) {
        const el = dieEls[i];
        const value = diceValues[i] ?? 0;
        const isHeld = held[i] ?? false;
        if (!el.firstChild || el.firstChild.nodeType !== Node.TEXT_NODE) {
          const textNode = document.createTextNode(String(value));
          el.insertBefore(textNode, el.firstChild);
        } else {
          el.firstChild.nodeValue = String(value);
        }
        if (isHeld) el.classList.add("die-held");
        else el.classList.remove("die-held");
      }
    }

    function renderRollInfo(rollsLeft) {
      if (rollsLeft == null) {
        rollInfo.textContent = "ì—°ê²° ì¤‘â€¦";
        rollInfo.classList.remove("warn");
        return;
      }
      rollInfo.textContent = `ë‚¨ì€ êµ´ë¦¼: ${rollsLeft} / ${MAX_ROLLS_PER_TURN}`;
      if (rollsLeft <= 0) rollInfo.classList.add("warn");
      else rollInfo.classList.remove("warn");
    }

    function renderTurnInfo(data) {
      if (!data || !currentUser) return;

      const players = data.players || {};
      const turn = data.turn;
      const currentPlayer = players[turn];
      const myInfo = players[currentUser.uid];

      const currentName = currentPlayer ? (currentPlayer.name || "í”Œë ˆì´ì–´") : "-";
      currentTurnNameEl.textContent = currentName;

      if (myInfo) myNameBadge.textContent = myInfo.name || "ë‚˜";

      if (data.finished) {
        turnHintEl.textContent = "ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìµœì¢… ì ìˆ˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.";
      } else if (turn === currentUser.uid && !isSpectator) {
        turnHintEl.textContent = "ì§€ê¸ˆì€ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤. ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦° ë’¤ ì ìˆ˜í‘œì—ì„œ ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”.";
      } else {
        const tn = currentName || "ë‹¤ë¥¸ í”Œë ˆì´ì–´";
        turnHintEl.textContent = `${tn}ì˜ í„´ì…ë‹ˆë‹¤.`;
      }

      const canAct = !data.finished && !isSpectator && turn === currentUser.uid;
      rollButton.disabled = !canAct || (data.rollsLeft ?? 0) <= 0;
    }

    // ==== UI: ì ìˆ˜í‘œ ====
    function renderScoreTable(data) {
      const players = data?.players || {};
      const scores = data?.scores || {};
      const turn = data?.turn;
      const dice = data?.dice || [];
      const finished = !!data?.finished;

      const playerIds = Object.keys(players).sort((a, b) => {
        const at = players[a].joinedAt || 0;
        const bt = players[b].joinedAt || 0;
        return at - bt;
      });
      playerOrder = playerIds;

      playerCountText.textContent = `${playerIds.length}ëª…`;

      const thead = [];
      thead.push("<thead><tr>");
      thead.push('<th class="category-header">ì¹´í…Œê³ ë¦¬</th>');
      for (const uid of playerIds) {
        const p = players[uid];
        const isMe = uid === currentUser?.uid;
        const isTurn = uid === turn && !finished;
        const dot = `<span class="pill-dot${isMe ? " me" : ""}"></span>`;
        thead.push(`<th>${dot} ${p.name || "í”Œë ˆì´ì–´"}${isTurn ? " â˜…" : ""}</th>`);
      }
      thead.push("</tr></thead>");

      const tbodyParts = [];
      tbodyParts.push("<tbody>");

      const canChoose = (uid, catKey, currentScores) => {
        if (finished) return false;
        if (!currentUser || isSpectator) return false;
        if (uid !== currentUser.uid) return false;
        if (turn !== currentUser.uid) return false;
        const ps = currentScores[uid] || {};
        if (ps[catKey] !== undefined && ps[catKey] !== null) return false;
        return true;
      };

      for (const cat of CATEGORIES) {
        tbodyParts.push("<tr>");
        tbodyParts.push(
          `<td class="score-category tooltip" data-tooltip="${cat.desc}" title="${cat.desc}">${cat.label}</td>`
        );

        for (const uid of playerIds) {
          const ps = scores[uid] || {};
          const val = ps[cat.key];
          const canClick = canChoose(uid, cat.key, scores);
          let classes = "score-cell";
          let display = "";

          if (val !== undefined && val !== null) {
            classes += " locked";
            display = String(val);
            if (cat.key === "yacht") {
              const yc = ps.yachtCount ?? 0;
              if (yc > 1) {
                display += ` (x${yc})`;
              }
            }
          } else if (canClick) {
            const candidate = computeScore(cat.key, dice);
            classes += " candidate";
            display = String(candidate);
          } else {
            classes += " disabled";
          }

          const cellAttr = canClick
            ? `data-uid="${uid}" data-category="${cat.key}"`
            : "";

          tbodyParts.push(`<td class="${classes}" ${cellAttr}>${display}</td>`);
        }

        tbodyParts.push("</tr>");

        // 6ëˆˆ í•©(sixes) ë°”ë¡œ ì•„ë˜ ë³´ë„ˆìŠ¤ í–‰
        if (cat.key === "sixes") {
          tbodyParts.push("<tr>");
          tbodyParts.push('<td class="score-category">ìƒë‹¨ ë³´ë„ˆìŠ¤</td>');
          for (const uid of playerIds) {
            const bonus = computeUpperBonus(scores[uid] || {});
            tbodyParts.push(`<td class="score-cell">${bonus}</td>`);
          }
          tbodyParts.push("</tr>");
        }
      }

      // í•©ê³„ (ìš”íŠ¸ ë³´ë„ˆìŠ¤ í¬í•¨)
      tbodyParts.push('<tr class="score-total-row">');
      tbodyParts.push('<th class="category-header">í•©ê³„</th>');
      for (const uid of playerIds) {
        const total = computePlayerTotal(scores[uid] || {});
        tbodyParts.push(`<td class="score-cell">${total}</td>`);
      }
      tbodyParts.push("</tr>");

      tbodyParts.push("</tbody>");

      scoreTableEl.innerHTML = thead.join("") + tbodyParts.join("");

      Array.from(scoreTableEl.getElementsByClassName("score-cell")).forEach((cell) => {
        if (cell.classList.contains("candidate")) {
          cell.addEventListener("click", onScoreCellClick);
        }
      });

      if (finished) {
        let bestUid = null;
        let bestScore = -Infinity;
        const ties = [];
        for (const uid of playerIds) {
          const total = computePlayerTotal(scores[uid] || {});
          if (total > bestScore) {
            bestScore = total;
            bestUid = uid;
            ties.length = 0;
            ties.push(uid);
          } else if (total === bestScore) {
            ties.push(uid);
          }
        }
        if (bestUid != null) {
          const names = ties.map((uid) => players[uid]?.name || "í”Œë ˆì´ì–´");
          scoreStatusEl.textContent = `ê²Œì„ ì¢…ë£Œ Â· ìµœê³  ì ìˆ˜: ${bestScore}ì  (${names.join(", ")})`;
        } else {
          scoreStatusEl.textContent = "ê²Œì„ ì¢…ë£Œ";
        }
        scoreStatusEl.classList.add("finished");
      } else {
        scoreStatusEl.textContent =
          "í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ëŠ” ì ìˆ˜í‘œì˜ ë¹ˆ ì¹¸ì„ ëˆŒëŸ¬ ì ìˆ˜ë¥¼ í™•ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ìš”íŠ¸ ì¶”ê°€ ë°œìƒ ì‹œ ë³´ë„ˆìŠ¤ 100ì )";
        scoreStatusEl.classList.remove("finished");
      }
    }

    // ==== íƒ€ì´ë¨¸ ====
    function startTurnTimer(data) {
      if (turnTimerInterval) {
        clearInterval(turnTimerInterval);
        turnTimerInterval = null;
      }

      if (!data || !turnTimerEl) return;

      if (data.finished) {
        turnTimerEl.textContent = "ê²Œì„ ì¢…ë£Œ";
        if (forceSkipButton) forceSkipButton.disabled = true;
        return;
      }

      const ts = data.turnStartedAt && data.turnStartedAt.toMillis
        ? data.turnStartedAt.toMillis()
        : null;

      if (!ts) {
        turnTimerEl.textContent = "ë‚¨ì€ ì‹œê°„: -";
        if (forceSkipButton) forceSkipButton.disabled = true;
        return;
      }

      function update() {
        const now = Date.now();
        const elapsed = Math.floor((now - ts) / 1000);
        const remaining = TURN_LIMIT_SECONDS - elapsed;

        if (remaining > 0) {
          const m = Math.floor(remaining / 60);
          const s = remaining % 60;
          turnTimerEl.textContent = `ë‚¨ì€ ì‹œê°„: ${m}:${String(s).padStart(2, "0")}`;
          if (forceSkipButton) forceSkipButton.disabled = true;
        } else {
          turnTimerEl.textContent = "ì œí•œì‹œê°„ ì´ˆê³¼";
          if (forceSkipButton && currentUser) {
            const players = data.players || {};
            const isInPlayers = !!players[currentUser.uid];
            const canSkip =
              !data.finished &&
              isInPlayers &&
              !isSpectator &&
              currentUser.uid !== data.turn;

            forceSkipButton.disabled = !canSkip;
          }
        }
      }

      update();
      turnTimerInterval = setInterval(update, 1000);
    }

    function updateRoomUI(data) {
      if (!data) return;
      latestRoomData = data;

      renderDice(data.dice || [], data.held || []);
      renderRollInfo(data.rollsLeft);
      renderTurnInfo(data);
      renderScoreTable(data);
      startTurnTimer(data);
    }

    // ==== ë°© ìƒì„±/ë¡œë”© ====
    async function ensureRoomExists(user) {
      roomId = getRoomIdFromUrlOrCreate();
      roomRef = doc(db, "rooms", roomId);
      roomIdText.textContent = `ë°© ${shortenId(roomId)}`;

      const snap = await getDoc(roomRef);
      const now = Date.now();

      if (!snap.exists()) {
        const initialDice = Array(NUM_DICE).fill(0);
        const initialHeld = Array(NUM_DICE).fill(false);
        await setDoc(roomRef, {
          createdAt: serverTimestamp(),
          players: {
            [user.uid]: {
              name: "í”Œë ˆì´ì–´",
              joinedAt: now
            }
          },
          dice: initialDice,
          held: initialHeld,
          rollsLeft: MAX_ROLLS_PER_TURN,
          turn: user.uid,
          scores: {},
          turnCounts: {
            [user.uid]: 0
          },
          finished: false
        });
      }

      onSnapshot(roomRef, (docSnap) => {
        if (!docSnap.exists()) return;
        const data = docSnap.data();
        isRoomReady = true;
        enterButton.disabled = false;
        spectateButton.disabled = false;
        updateRoomUI(data);
      });
    }

    // ==== ì•¡ì…˜ ====
    async function rollDice() {
      if (!roomRef || !currentUser || isSpectator) return;

      const snap = await getDoc(roomRef);
      if (!snap.exists()) return;
      const data = snap.data();

      if (data.finished) return;
      if (data.turn !== currentUser.uid) return;

      const rollsLeft = data.rollsLeft ?? MAX_ROLLS_PER_TURN;
      if (rollsLeft <= 0) return;

      const dice = data.dice || Array(NUM_DICE).fill(0);
      const held = data.held || Array(NUM_DICE).fill(false);

      const newDice = dice.map((v, i) =>
        held[i] ? v : Math.floor(Math.random() * 6) + 1
      );

      const updates = {
        dice: newDice,
        rollsLeft: rollsLeft - 1
      };

      // ì´ë²ˆ í„´ì˜ ì²« êµ´ë¦¬ê¸°ë¼ë©´ ì´ë•Œë¶€í„° íƒ€ì´ë¨¸ ì‹œì‘
      if (!data.turnStartedAt) {
        updates.turnStartedAt = serverTimestamp();
      }

      await updateDoc(roomRef, updates);
    }

    async function toggleHold(index) {
      if (!roomRef || !currentUser || isSpectator) return;
      const snap = await getDoc(roomRef);
      if (!snap.exists()) return;
      const data = snap.data();
      if (data.finished) return;
      if (data.turn !== currentUser.uid) return;

      const held = data.held || Array(NUM_DICE).fill(false);
      const newHeld = [...held];
      newHeld[index] = !newHeld[index];

      await updateDoc(roomRef, { held: newHeld });
    }

    async function chooseCategory(uid, categoryKey) {
      if (!roomRef || !currentUser || isSpectator) return;
      if (uid !== currentUser.uid) return;

      const snap = await getDoc(roomRef);
      if (!snap.exists()) return;
      const data = snap.data();
      if (data.finished) return;
      if (data.turn !== currentUser.uid) return;

      const players = data.players || {};
      const scores = data.scores || {};
      const dice = data.dice || [];
      const turnCounts = data.turnCounts || {};

      const playerIds = Object.keys(players).sort((a, b) => {
        const at = players[a].joinedAt || 0;
        const bt = players[b].joinedAt || 0;
        return at - bt;
      });

      const myScores = scores[currentUser.uid] || {};
      if (myScores[categoryKey] !== undefined && myScores[categoryKey] !== null) return;

      const scoreVal = computeScore(categoryKey, dice);

      // ìš”íŠ¸ ë¡¤ì¸ì§€ ì²´í¬
      const isYachtRoll = computeScore("yacht", dice) > 0;
      let yachtCount = myScores.yachtCount ?? 0;

      if (isYachtRoll) {
        // ìš”íŠ¸ ì¹¸ì´ ì´ë¯¸ ì±„ì›Œì§„ í›„ì— ë˜ ìš”íŠ¸ê°€ ë‚˜ì˜¤ë©´ ì¶”ê°€ ë³´ë„ˆìŠ¤
        if (myScores.yacht != null) {
          yachtCount = yachtCount > 0 ? yachtCount + 1 : 2;
        } else if (categoryKey === "yacht") {
          // ì²« ìš”íŠ¸ë¥¼ ìš”íŠ¸ ì¹¸ì— ì±„ìš°ëŠ” ê²½ìš°
          yachtCount = yachtCount > 0 ? yachtCount : 1;
        }
      }

      const myNewScores = { ...myScores, [categoryKey]: scoreVal };
      if (isYachtRoll && yachtCount > 0) {
        myNewScores.yachtCount = yachtCount;
      }

      const myTurnCount = (turnCounts[currentUser.uid] ?? 0) + 1;
      const newTurnCounts = { ...turnCounts, [currentUser.uid]: myTurnCount };

      const updateData = {
        [`scores.${currentUser.uid}.${categoryKey}`]: scoreVal,
        turnCounts: newTurnCounts
      };
      if (isYachtRoll && yachtCount > 0) {
        updateData[`scores.${currentUser.uid}.yachtCount`] = yachtCount;
      }

      const done = allTurnsFinished(newTurnCounts, playerIds);

      if (done) {
        updateData.finished = true;
      } else {
        const idx = playerIds.indexOf(currentUser.uid);
        const nextIdx = (idx + 1) % playerIds.length;
        const nextUid = playerIds[nextIdx];

        updateData.turn = nextUid;
        updateData.rollsLeft = MAX_ROLLS_PER_TURN;
        updateData.held = Array(NUM_DICE).fill(false);
        updateData.dice = Array(NUM_DICE).fill(0);
        updateData.turnStartedAt = serverTimestamp();
      }

      await updateDoc(roomRef, updateData);
    }

    // ê°•ì œ í„´ ë„˜ê¸°ê¸°:
    // ì‹œê°„ ì´ˆê³¼ëœ í”Œë ˆì´ì–´ëŠ” ì¹´í…Œê³ ë¦¬ì—ëŠ” ì•„ë¬´ ë³€í™” ì—†ì´,
    // "í„´ì„ 1ë²ˆ ì‚¬ìš©í•œ ê²ƒ"ìœ¼ë¡œë§Œ ì¹´ìš´íŠ¸. (ê°ì 13í„´ ì±„ìš°ë©´ ê²Œì„ ì¢…ë£Œ)
    async function forceSkipTurn() {
      if (!roomRef || !currentUser || isSpectator) return;
      const snap = await getDoc(roomRef);
      if (!snap.exists()) return;
      const data = snap.data();
      if (data.finished) return;

      const ts = data.turnStartedAt && data.turnStartedAt.toMillis
        ? data.turnStartedAt.toMillis()
        : null;
      if (!ts) return;

      const elapsed = (Date.now() - ts) / 1000;
      if (elapsed < TURN_LIMIT_SECONDS) return;

      const players = data.players || {};
      const scores = data.scores || {};
      const turnCounts = data.turnCounts || {};

      const playerIds = Object.keys(players).sort((a, b) => {
        const at = players[a].joinedAt || 0;
        const bt = players[b].joinedAt || 0;
        return at - bt;
      });
      if (!playerIds.length) return;

      // í˜„ì¬ í„´ì¸ ì‚¬ëŒì€ ìê¸° í„´ì„ ê°•ì œ ë„˜ê¸¸ ìˆ˜ ì—†ìŒ
      if (currentUser.uid === data.turn) return;

      const skippedUid = data.turn;

      const skippedTurnCount = (turnCounts[skippedUid] ?? 0) + 1;
      const newTurnCounts = { ...turnCounts, [skippedUid]: skippedTurnCount };

      const updates = {
        scores: scores,
        turnCounts: newTurnCounts
      };

      const done = allTurnsFinished(newTurnCounts, playerIds);

      const idx = playerIds.indexOf(skippedUid);
      const nextIdx = (idx + 1) % playerIds.length;
      const nextUid = playerIds[nextIdx];

      if (done) {
        updates.finished = true;
      } else {
        updates.turn = nextUid;
        updates.rollsLeft = MAX_ROLLS_PER_TURN;
        updates.held = Array(NUM_DICE).fill(0);
        updates.dice = Array(NUM_DICE).fill(0);
        updates.turnStartedAt = serverTimestamp();
      }

      await updateDoc(roomRef, updates);
    }

    // ==== ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ====
    function onDieClick(index) {
      if (!latestRoomData) return;
      toggleHold(index).catch(console.error);
    }

    function onScoreCellClick(e) {
      const cell = e.currentTarget;
      const uid = cell.getAttribute("data-uid");
      const cat = cell.getAttribute("data-category");
      if (!uid || !cat) return;
      chooseCategory(uid, cat).catch(console.error);
    }

    async function setDisplayNameAsPlayer() {
      const raw = nameInput.value.trim();
      if (!raw) {
        nameInput.focus();
        return;
      }
      if (!roomRef || !currentUser) return;

      const name = raw;
      try {
        const snap = await getDoc(roomRef);
        if (!snap.exists()) return;
        const data = snap.data() || {};
        const players = data.players || {};
        const turnCounts = data.turnCounts || {};
        const now = Date.now();

        const updates = {};
        updates[`players.${currentUser.uid}.name`] = name;
        if (!players[currentUser.uid]) {
          updates[`players.${currentUser.uid}.joinedAt`] = now;
        }
        if (turnCounts[currentUser.uid] == null) {
          updates[`turnCounts.${currentUser.uid}`] = 0;
        }

        await updateDoc(roomRef, updates);

        localStorage.setItem("yachtName", name);
        myNameBadge.textContent = name;
        isSpectator = false;
        nameOverlay.style.display = "none";
        showToast("í”Œë ˆì´ì–´ë¡œ ì…ì¥í–ˆìŠµë‹ˆë‹¤.");
      } catch (e) {
        console.error(e);
        showToast("ë‹‰ë„¤ì„ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", 2000);
      }
    }

    function enterAsSpectator() {
      const raw = nameInput.value.trim();
      if (raw) {
        myNameBadge.textContent = raw;
        localStorage.setItem("yachtName", raw);
      }
      isSpectator = true;
      nameOverlay.style.display = "none";
      showToast("ê´€ì „ ëª¨ë“œë¡œ ì…ì¥í–ˆìŠµë‹ˆë‹¤.");
    }

    // ==== ì´ˆê¸° ì„¸íŒ… ====
    function setupEvents() {
      rollButton.addEventListener("click", () => {
        rollDice().catch(console.error);
      });

      forceSkipButton.addEventListener("click", () => {
        forceSkipTurn().catch(console.error);
      });

      enterButton.addEventListener("click", () => {
        if (!isRoomReady) {
          showToast("ë°©ì„ ì¤€ë¹„í•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.", 2000);
          return;
        }
        setDisplayNameAsPlayer().catch(console.error);
      });

      spectateButton.addEventListener("click", () => {
        if (!isRoomReady) {
          showToast("ë°©ì„ ì¤€ë¹„í•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.", 2000);
          return;
        }
        enterAsSpectator();
      });

      nameInput.addEventListener("input", () => {
        const hasText = nameInput.value.trim().length > 0;
        if (isRoomReady) {
          enterButton.disabled = !hasText;
          spectateButton.disabled = !hasText;
        }
      });

      nameInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          enterButton.click();
        }
      });

      copyLinkBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(window.location.href);
          showToast("ë§í¬ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.");
        } catch {
          showToast("ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì£¼ì†Œì°½ ë§í¬ë¥¼ ì§ì ‘ ë³µì‚¬í•´ ì£¼ì„¸ìš”.", 2200);
        }
      });

      const savedName = localStorage.getItem("yachtName");
      if (savedName) nameInput.value = savedName;
    }

    function initFirebaseAuthAndRoom() {
      onAuthStateChanged(auth, async (user) => {
        try {
          if (!user) {
            const cred = await signInAnonymously(auth);
            currentUser = cred.user;
          } else {
            currentUser = user;
          }
          await ensureRoomExists(currentUser);
        } catch (e) {
          console.error(e);
          showToast("ì„œë²„ ì—°ê²° ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", 2200);
        }
      });

      if (!auth.currentUser) {
        signInAnonymously(auth).catch(console.error);
      }
    }

    // ì‹œì‘
    createDiceUI();
    setupEvents();
    initFirebaseAuthAndRoom();
    renderDice(Array(NUM_DICE).fill(0), Array(NUM_DICE).fill(false));
    renderRollInfo(null);
  </script>
</body>
</html>
